#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/poll.h>
#include <sys/ioctl.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>

/*struct hci_filter {
         unsigned long type_mask;
         unsigned long event_mask[2];
         __le16 opcode;
 };
*/

/*#define OCF_INQUIRY             0x0001
 struct hci_cp_inquiry {
         __u8     lap[3];
         __u8     length;
         __u8     num_rsp;
 } __attribute__ ((packed));
*/

/*struct hci_event_hdr {
         __u8    evt;
         __u8    plen;
 } __packed;
*/

// POLL description : http://man7.org/linux/man-pages/man2/poll.2.html.

/*
  Informations gathered from : http://people.csail.mit.edu/albert/bluez-intro/x682.html.

  Described function(s) :

  int hci_send_cmd(int sock, uint16_t ogf, uint16_t ocf, uint8_t plen, void *param);

  Needed librarie(s) :

  #include <bluetooth/hci.h>
  #include <bluetooth/hci_lib.h> (?)

  * MAIN PURPOSE : sending a command to the BT microcontroller.
  -> parameters :
    - int sock : a socket descriptor (the socket has to be open).
    - uintl16_t ogf : the Opcode Group Field that specifies the general category the command falls into.
    - uint16_t ocf : the Opcode Command Field that specifies the actual command.
    - uint8_t plen : the length of the command parameters "param".
    - void *param : a buffer containing the command parameters (a.k.a CP).
  * NOTE :
  Calling read on an open HCI socket waits for and receives the next event from the microcontroller.
  An event consists of a header field specifying the event type, and the event parameters.
  A program that requires asynchronous device detection would, for example, send a command with
  ocf of "OCF_INQUIRY" and wait for events of type "EVT_INQUIRY_RESULT" and "EVT_INQUIRY_COMPLETE".
  The specific codes to use for each command and event are defined in the specifications and
  in the BlueZ source code. 
*/

/*
  Informations gathered from : http://linux.die.net/man/2/setsockopt.

  Described function(s) :

  int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
  int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

  Needed librarie(s) :

  #include <sys/types.h>          
  #include <sys/socket.h>

  * MAIN PURPOSE : manipulating socket options.
  -> getsockopt() parameters :
     - int sockfd : a socket descriptor.
     - int level : the level at which the option resides. That is to say that we need to specify
     the level (in the protocol stack) of the used protocol. In our case, we might want to use
     the "SOL_HCI" level which corresponds to the HCI protocol.
     - int optname : the name of the option to be modified. That name depends on the used protocol but
     in our case, we might want to modify for instance, the "HCI_FILTER" option.
     - void *optval : a buffer in which the value for the requested option(s) are to be returned.
     - socklen_t *optlen : initially contains the size of the buffer pointed by "optval" and
     modified on return to indicate the actual size of the returned value. If no option value
     is to be returned, optval may be NULL.
   -> setsockopt() parameters :
     - int sockfd : same as "getsockopt()" parameter.
     - int level : same as "getsockopt()" parameter.
     - int optname : same as "getsockopt()" parameter.
     - const void *optval : contains the options values (buffer).
     - socklen_t optlen : contains the size of the previous buffer.
   * RETURN VALUE :
     - On succes : 0.
     - On error : -1 + errno set appropriately (see the link above).
*/

#define NAME_LENGTH 50

struct rssi_t {
	bdaddr_t device_mac;
	int16_t rssi;
};

typedef struct {
	bdaddr_t mac;
	char name[NAME_LENGTH];
} device_info;

typedef struct {
	device_info *di;
	uint16_t length;
} di_table;

// Inquiry duration = scan_duration*1.28s
di_table *scan_devices(int scan_duration, int max_rsp, long flags) {
	// Creation of the inquiry_info table :
	inquiry_info *ii = calloc(max_rsp, sizeof(inquiry_info));
	
	// Creation of the descriptor and opening of an hci socket :
	int dev_id = hci_get_route(NULL); // NULL => we take the first present BT adaptator.
	int sock = hci_open_dev(dev_id);
	if (dev_id < 0 || sock < 0) {
		perror("opening socket");
		free(ii);
		return NULL;
	}

	// Starting the inquiry :
	fprintf(stderr, "Starting the inquiry...");
	int nb_rsp = hci_inquiry(dev_id, scan_duration, max_rsp, NULL, &ii, flags); 
	if( nb_rsp < 0 ) {
		perror("hci_inquiry");
		free(ii);
		close(sock);
		fprintf(stderr, " [ERROR]\n");
		return NULL;
	}
	fprintf(stderr, " [DONE]\n");
	
	di_table *ditable = (di_table *)malloc(sizeof(di_table));
	device_info *result = calloc(nb_rsp, sizeof(device_info));

	for (uint16_t i = 0; i < nb_rsp; i++) {
		result[i].mac = ii[i].bdaddr;
		if (hci_read_remote_name(sock, &(ii[i].bdaddr), NAME_LENGTH, result[i].name, 0) < 0) {
			strcpy(result[i].name, "[UNKNOWN]");
		}
	}

	free(ii);
	close(sock); 

	ditable->di = result;
	ditable->length = nb_rsp;

	return ditable;
}	

void display_device_info(device_info di) {
	char tmp[18];
	fprintf(stdout, "[%s] : %16s \n", ba2str(&(di.mac), tmp), di.name);
}

int main(int argc, char **argv)
{
	di_table *ditable = NULL; 
	ditable = scan_devices(5, 50, IREQ_CACHE_FLUSH);
	if (ditable == NULL) {
		fprintf(stderr, "Error while scanning devices... \n");
		return EXIT_FAILURE;
	}
	for (uint16_t i = 0; i < ditable->length; i++) {
		display_device_info(ditable->di[i]);
	}
	return EXIT_SUCCESS;
}
 
